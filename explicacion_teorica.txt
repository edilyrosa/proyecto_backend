**********************BASE DE DATOS - SUPABASE

1ï¸âƒ£ RegÃ­strate y Crear un proyecto en Supabase.
RegÃ­strate en https://supabase.com/

A. sign up -> correo || GitHub -> Check your email to confirm-> 

B. Te redirecciona al dashboard de SupaBase, pestana New organization -> 
New organization: acepta los valores defaults y click en "create organization"

C. Create a new project -> Rellena: Database Password y Region (South America), 
acepta los demas valores defaults y click en "create new project"

D. En Project API copia los siguientes valores (esta en el 1er icono "Project Overview"), 
â­copia estos secretos, porque seran las credenciales usadas en el backend para 
conectarte a las tablas que crees en este proyecto: 
âœ…Project URL: https://zqgdtbocblpyjdvcyqhp.supabase.co
âœ…API Key: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIs...
MIRAR (IMG 1)
para la conexiÃ³n bÃ¡sica y las operaciones comunes desde un backend de Node.js, 
la combinaciÃ³n de la Project URL y la anon public API Key es la forma estÃ¡ndar y segura.

â­â­â­ğŸ§ ğŸ‘€6ï¸âƒ£En el proyecto backend, crearas el archivo .env y pega esos datos secretos, que son la llave para 
conectar la BBDD Supa con nuestro Backend, y desde alla acceder a la data. Estas variables de entorno seran usadas 
como parametron para crear un ClientSupa que representa una promesa (especie de fetch) que trae la data de la 
BD para ser servida por el backend.
ğŸš«âŒğŸš«âŒğŸš©ğŸš©ğŸš©No uses la clave service_role en el frontend: Esta clave tiene permisos totales y debe mantenerse s
egura en el backend. En el frontend solo usa la clave anon (que tiene permisos limitados y estÃ¡ sujeta a las polÃ­ticas RLS).



2ï¸âƒ£Crear la tabla usuarios
En el panel izquierdo -> "Table Editor" ->  + new table ->  nombre a la tabla: "usuarios" -> 
escroll down -> click sobre "add column": llena las casillas para dar nombre y establecer el TDD 
de la columna, hazlo tantas columnas tenga tu tabla, ejemplo: nombre, edad, email, foto, aceptacion y genero (la columna id, se crea automaticamente) ->   save. 
MIRAR (IMG 2)


3ï¸âƒ£ Inserta registros en la tabla que has creeado -> insert -> insert row
MIRAR (IMG 3)


ğŸ§ â­ Puedes hacerlo tambien en el SQL Editor
âœï¸
INSERT INTO usuarios (nombre, edad, email, foto, aceptacion, genero)
VALUES (
  'Karla Rojas', 
  33,
  'ka@gmail.com', 
  'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTj62bw4TZh2Tdbt269A3qdB2Bk6yxwOpxeLw&s', 
  12, 
  true
);




4ï¸âƒ£Click sobre: Add RLS Policy
Configura polÃ­ticas de Row Level Security (RLS) para la tabla. Por defecto, 
Supabase bloquea todas las operaciones hasta que definas polÃ­ticas explÃ­citas.

Paso 1: Habilitar RLS en la tabla usuarios (si no estÃ¡ habilitado)
Ejecuta este SQL en el SQL Editor de Supabase:

âœï¸
ALTER TABLE usuarios ENABLE ROW LEVEL SECURITY; 
click sobre "Run CTRL"
Asegurate de obtener el mensaje de exito: "Success. No rows returned"
MIRAR (IMG 4 y 5)

Paso 2: Crear polÃ­ticas para permitir el acceso desde tu backend
PolÃ­tica para SELECT (leer usuarios)
Permite que tu backend obtenga todos los usuarios usando la clave de servicio (service key):
Tal y como lo hiciste en el paso anterior, ejecuta este SQL en el SQL Editor de Supabase y Asegurate de 
obtener el mensaje de exito: "Success. No rows returned":
âœï¸ 
CREATE POLICY "Allow public select" ON usuarios
FOR SELECT
TO anon
USING (true);


ğŸ’¡RLS se activa por tabla, ya deberias tener la tuya activa en la tabla usuarios. 
Cada tabla puede tener sus propias polÃ­ticas de seguridad. No existe un interruptor 
global para activar RLS en todo el proyecto. Esto te permite controlar el acceso de forma granular 
y segura segÃºn las necesidades especÃ­ficas de cada conjunto de datos.





**************************BACKEND - SERVIDOR WEB.

ğŸ’»NECESITAS node.js
Para verificar si Node.js y npm estÃ¡n instalados en tu SO, abre tu terminal o lÃ­nea de comandos y ejecuta:
node -v
npm -v

ğŸš«âŒSi te aparece un error, debes instalarlo: Ve a la pÃ¡gina oficial de Node.js: https://nodejs.org/
Descarga e instala la versiÃ³n LTS (Long Term Support), que es la recomendada para la mayorÃ­a de los usuarios.

1ï¸âƒ£Crea una carpeta para tu proyecto.
2ï¸âƒ£Corre:  
ğŸŒŸğŸŒŸnpm init -y 
En la terminal, para inicializar el proyecto. Se creara el archivoÂ "package.json", que lo siguiente:
	âœ…"name": "backend-usuarios",
	âœ…"version": "1.0.0",
	âœ…"main": "index.js", ->  || app.js || server.js, el nombre de tu archivo principal
	â•"type":"module", -> Add esto para usar ES6 default (import/export), deja de usar .mjs
	âœ…"scripts": {
    ...
     â•"start": "node index.js" -> Igual al value de "main", sera necesario para cuando desplegemos el proyecto, 
     nos pediren el script de arranque
  } 
	âŒšdependencies:{}
	âŒšdevDependencies:{} ->  Usando el indicador -D 
	âŒš...

3ï¸âƒ£Instalamos los mÃ³dulos o paquetes de los cuales dependera nuestro proyecto, como: 
ğŸŒŸğŸŒŸnpm i express
ğŸŒŸğŸŒŸnpm install cors   -> evitar problemas con los origines entre front y back
ğŸŒŸğŸŒŸnpm install @supabase/supabase-js
ğŸŒŸğŸŒŸnpm install dotenv -> para leer las variables de entorno, los secretos de las APIS

La primera instalacion creara: 
âœ…node_modules/      â†’ğŸ’¡ğŸš©Incluise en .gitignore
âœ…package-lock.json  â†’ğŸ’¡ğŸš©si hay problema con package.json â†’ overwrite â†’ otra vez install dependences


4ï¸âƒ£Crea los siguientes archivos en la raÃ­z de tu proyecto (donde estÃ¡ tu package.json).
âœ… index.js || app.js || server.js
âœ….gitignore
âœ….env        ->ğŸ’¡ğŸ‘€ğŸš©Incluir en .gitignore
âœ…supabaseClient.js

*********************5ï¸âƒ£ En index.js: creaciÃ³n de servidor web con el framework express.js
//? Importar: express y cors, crea app con express() y usalos:
const PORT = 3000
const app = express()
app.use(express.json()); // Parsear JSON en las peticiones
app.use(cors()); // Habilitar CORS para todos los orÃ­genes
app.get('/usuarios',  async (req, res) =>{})
app.listen(PORT, ()=>{ log()}) 
-> ejecuta: nodemon index.js

ğŸ§ ğŸ¤¯nodemon: Es Ãºtil para desarrollo, al expiar los archivos y hacer que el servidor se 
reinicie cuando cambien. 
â‰ï¸ğŸ™‹ğŸ½â€â™€ï¸como se si ya tengo nodemon, ejecuta en la terminal:
nodemon -v

Si no lo tienes, instalalo.
Instalacion: instala nodemon globalmente te permite usarlo en cualquier proyecto 
sin tener que instalarlo repetidamente.
âœï¸
npm install -g nodemon -> El -g significa "global

Una vez instalado, en lugar de ejecutar tu aplicaciÃ³n con node lo haces con nodemon, asi:
ğŸš«node index.js,    -> ğŸ‘€ğŸ³ï¸Seguira siendo tu script default, para desplegar. MANTENLO!
âœ…nodemon index.js


********************6ï¸âƒ£En supabaseClient.js: Configurar el cliente en tu backend.
// supabaseClient.js
import dotenv from 'dotenv'; //todo: add esto
dotenv.config();//todo: add esto
import { createClient } from '@supabase/supabase-js'
const supabaseUrl = 'https://flrhaoijvzluodziysoq.supabase.co'
const supabaseKey = process.env.SUPABASE_KEY
export const supabase = createClient(supabaseUrl, supabaseKey)

********************7ï¸âƒ£En .env 
SUPABASE_KEY=eyJhbGciOiJIUzI1NiIsInR5...

********************8ï¸âƒ£Vuelve al index.js consume y usa las tablas de supabase
import { supabase } from './supabaseClient.js' //****AQUIIIII!!*****
import express from "express";
import cors from 'cors';

const app = express()
const PORT = 3000

app.use(express.json()); // Parsear JSON en las peticiones
app.use(cors()); // Habilitar CORS para todos los orÃ­genes


*******************GENERALIDADES********************
Express hay varios mÃ©todos del objeto res para enviar respuestas o manejar la respuesta al cliente, entre los principales estÃ¡n:

res.send(): EnvÃ­a datos (HTML, texto, JSON, buffers) y termina la respuesta.

res.json(): EnvÃ­a una respuesta JSON, serializando automÃ¡ticamente el objeto pasado.

res.status(): Define el cÃ³digo de estado HTTP de la respuesta (por ejemplo, 200, 404).

res.sendFile(): EnvÃ­a un archivo como respuesta, Ãºtil para servir archivos estÃ¡ticos.

res.end(): Termina la respuesta sin enviar datos adicionales (menos frecuente sin combinar).

res.redirect(): Redirige al cliente a otra URL.

res.render(): Usa un motor de plantillas para renderizar y enviar vistas dinÃ¡micas (si tienes configurado un motor de plantillas).

Estos mÃ©todos se pueden combinar para formar respuestas completas, y algunos devuelven el objeto de respuesta para encadenar llamadas (por ejemplo, res.status(404).send('Not found')). AsÃ­ puedes manejar distintos escenarios y tipos de respuesta en tu servidor Express.

app.get('/', (req, res) => {
  res.status(200).send(`<h1 style="text-align: center; color: red;">conectadoğŸš€ en el puerto ${PORT}</h1>`);
});

 ***********

app.use((req, res) => {
  res.status(404).send(`<h1 style="text-align: center; color: red;"> âŒError 404 âŒ</h1>`);
});
Esta ruta usa app.use sin especificar mÃ©todo ni ruta, por lo que actÃºa como "catch-all" para cualquier peticiÃ³n que no coincida con rutas previas. AquÃ­ se establece el cÃ³digo de estado 404 y se envÃ­a el mensaje con estilo HTML.

Es importante que esta ruta sea la Ãºltima en definirse, despuÃ©s de todas tus rutas normales, ya que Express las evalÃºa en orden y la primera que coincida responde la peticiÃ³n.

AsÃ­, si un usuario entra a una URL no configurada en tu servidor, verÃ¡ la pÃ¡gina de error 404 personalizada que definiste. Esta es la forma estÃ¡ndar y recomendada para manejar errores 404 en Express.â€‹
****************************************************













app.get('/usuarios', async (req, res) => {
    const { data, error } = await supabase //****AQUIIIII!!*****
      .from('usuarios')
      .select('*')  // Selecciona todas las columnas
  
    if (error) {
      console.error('Error al obtener usuarios:', error)
      return res.status(500).send('Error al obtener usuarios')
    }
  
    res.json(data) // EnvÃ­a los usuarios como JSON
  })

app.listen(PORT, ()=>{
    console.log(`Servidor corriendo en http://localhost:${PORT}`);
})

ğŸ’¡ExplicaciÃ³n: 
upabase.from('usuarios').select('*') hace una consulta SELECT a la tabla usuarios en tu base de datos 
Supabase. Si hay un error, responde con cÃ³digo 500 y un mensaje. Si todo va bien, responde con los datos en formato JSON.



********************9ï¸âƒ£En .gitignore
# Environment variables
.env
...
# Node.js dependencies
node_modules/
...
 








######################## ENDPOINTS: GET/ID, POST, PUT Y DELETE.
1. CODIGO EN GET/ID EN BACKEND.
//Obtener usuario por ID: https://supabase.com/docs/reference/javascript/using-filters
//TODO: Obtener usuario por ID:  API Docus -> tables & views -> Read rows -> Filtering ->  // Filters .eq('column', 'Equal to')
app.get("/usuarios/:id", async (req, res) => {
    const id = parseInt(req.params.id)
   const {data, error} = await supabase.from('usuarios').select('*').eq('id', id).single()
    if(error) return res.status(500).json({error:'Error la obtener al usuario, BACK'})
    if(!data) return res.status(404).json({error:'Error para encontrar al usuario, BACK'})
    res.json(data)
})


2. CODIGO EN POST EN BACKEND.
//TODO: Crear nuevo usuario: API Docus -> tables & views -> Insert a row
app.post("/usuarios", async (req, res )=> {
    const usuario = req.body
     
    if( //*Si el frontend envÃ­a explÃ­citamente null, tu backend lo aceptarÃ­a y enviaria a la BBDD. Validar el client.body
        !usuario.nombre ||
        !usuario.email ||
        !usuario.foto ||
        usuario.edad === undefined ||       // !0 es true y eso harÃ­a fallar la validaciÃ³n errÃ³neamente.
        usuario.aceptacion === undefined || //!  usuario.edad === undefined o usuario.edad == null (detecta null o undefined).
        usuario.genero === undefined
    ) return res.status(400).json({error:'Faltan datos para hacer post de usuario, BACK'})

    const {data, error} = await supabase.from('usuarios').insert([{...usuario}]).select().single() //*Enviamos y lo recuperamos

    if(error) return res.status(500).json({error:'Error al crear/postear nuevo usario, BACK'})

    res.json(data)
})


3. CODIGO EN PUT EN BACKEND.
// Actualizar usuario por ID: API Docus -> tables & views -> Update rows
app.put("/usuarios/:id", async (req, res)=> {
  const id =  parseInt(req.params.id)
  const usuario = req.body

    if( //*Si el frontend envÃ­a explÃ­citamente null, tu backend lo aceptarÃ­a y enviaria a la BBDD. Validar el client.body
        usuario.nombre === undefined &&
        usuario.email === undefined &&
        usuario.foto === undefined &&
        usuario.genero === undefined &&
        usuario.aceptacion === undefined && 
        usuario.edad === undefined
    ) return res.status(400).json({error: 'Almenos un campo debe ser enviado para actualizar/put'})
    
    //*Creamos el Obj a enviar para actualizar el resgistro del ID.
    const camposActualizar = {}
    if(usuario.nombre !== undefined) camposActualizar.nombre = usuario.nombre;
    if(usuario.edad !== undefined && usuario.edad !== null)  camposActualizar.edad = usuario.edad;
    if(usuario.email !== undefined) camposActualizar.email = usuario.email;
    if(usuario.foto !== undefined) camposActualizar.foto = usuario.foto;
    if(usuario.aceptacion !== undefined && usuario.aceptacion !== null) camposActualizar.aceptacion = usuario.aceptacion;
    if(usuario.genero !== undefined) camposActualizar.genero = usuario.genero;

    const {data, error} = await supabase.from('usuarios').update(camposActualizar).eq('id', id).select()

    if(error) res.status(500).json({error:'Error al actualizar el usuario BACK'})
    if(data.length === 0) res.status(404).json({error:'Usuario no encontrado, BACK'})
      res.json(data[0]) //? Enviamos el usuario actualizado
})



3. CODIGO EN DELETE EN BACKEND.
// //todo: Eliminar usuario por ID: API Docus -> tables & views -> Delete rows
 app.delete("/usuarios/:id", async (req, res) => {
   const id = parseInt(req.params.id);
   const { data, error } = await supabase.from("usuarios").delete().eq("id", id).select();

   if (error) {
     console.error("Error al eliminar usuario", error);
     return res.status(500).json({ error: "Error al eliminar usuario BACK" });
   }

   if (data.length === 0) return res.status(404).json({ error: "Usuario no encontrado" });
   res.status(200).send();
 })























































*****************DESPLIEGUE DEL BACKEND
Una vez que tienes tu backend configurado para usar Supabase (con las variables de entorno, 
rutas que consultan la base de datos y las polÃ­ticas RLS bien definidas), el siguiente paso 
lÃ³gico es desplegar tu backend para que estÃ© disponible pÃºblicamente y tu frontend pueda consumirlo.

Pasos para desplegar tu backend Node.js + Express:
1ï¸âƒ£Elegir un servicio de hosting para desplegar backend Node.js. Usaremos Render (https://render.com), registrate con GitHub.

2ï¸âƒ£Preparar tu proyecto para producciÃ³n: 
âœ…Configura tu backend para leer las variables de entorno (usando dotenv o la configuraciÃ³n del host).
âœ…En tu package.json, define el script para iniciar el servidor, por ejemplo:
"scripts": {
  "start": "node index.js"
}

3ï¸âƒ£Subir tu cÃ³digo a un repositorio GitHub con "Publish to GitHub", para facilitar despliegues automÃ¡ticos. 
Entonces, crea un repositorio y sube tu proyecto backend, NO SIN ANTES LLENAR TU file .gitignore

4ï¸âƒ£Configurar el despliegue en la plataforma Render
1. Crear un nuevo servicio en Render: En el dashboard de Render, en el header haz clic en "New" -> "Web Service" 
-> GitHub. Scroll down -> Only select repositories -> Select repositories -> elige tu repositorio Git donde 
estÃ¡ tu backend (por nombre o URL). Render detectarÃ¡ que es un proyecto Node.js. -> save || connect
1.1 casillas de info del proyecto: Node, main, npm install, â­node index.jsâ­, clic on capa Free

2. Scroll down -> Configura las variables de entorno en el panel de Render (pues .env es IGNORADA por GitHub). 
SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_ANON_KEY,..., copialas y pegalas, estan en .env de tu proyecto backend-node
Entonces, si usas variables de entorno, asegÃºrate de tener un archivo .env local para desarrollo y luego 
configurar esas variables en Render.

3. -> Deploy Web Services: Despliega la app y verifica que el backend estÃ© corriendo.
Tu backend debe escuchar en el puerto que Render asigna, normalmente se usa process.env.PORT:

En la terminal de render, debe aparecer algo como:
==> ///////////////////////////////////////////////////////////
==> 
==> Available at your primary URL https://backend-qi8u.onrender.com
==> 
==> ///////////////////////////////////////////////////////////
==> Detected a new open port HTTP:3001



5ï¸âƒ£
5. Probar el backend desplegado
Accede a la URL pÃºblica que te da la plataforma, por ejemplo:

text
https://backend-qi8u.onrender.com/â­usuariosâ­
Haz peticiones GET, POST, PUT, DELETE para verificar que todo funciona correctamente.

6. Actualizar el frontend
Cambia la URL de la API en tu frontend para que apunte al backend desplegado.

Por ejemplo:
js
const API_URL = "https://backend-qi8u.onrender.com/usuarios"

ğŸ‘€ğŸ‘€ğŸ‘€ğŸ‘€ğŸš©ğŸš©ğŸš©ğŸš©CADA QUE HAGAS CAMBIOS EN TU CODIGO BACKEND, DEBES HACER REDEPLOY EN RENDER DE TU SERVIDOR!!ğŸ‘€ğŸ‘€ğŸ‘€ğŸ‘€ğŸ‘€ğŸš©ğŸš©ğŸš©ğŸš©ğŸš©
 con clic on -> "Manual Deply", pero antes haz commit en GutHub del cambio !!






######################### CONFIGURACION DEL CORS: ORIGENES ENTRE BACK Y FRONTEND
1ï¸âƒ£

app.use(cors()) ||   app.use(cors({ origin:'*'}))




2ï¸âƒ£
//*ğŸ‘€ğŸ‘€ğŸ‘€ğŸ‘€ğŸš©ğŸš©ğŸš©ğŸ¤¯ en la URL de los origin permitidos ğŸš«âŒNO COLOCAR path ->./index.htmlâŒğŸš« 

app.use(cors({
  origin:'http://127.0.0.1:5501ğŸš«/index.htmlğŸš«'
}))



3ï¸âƒ£
const allowedOrigins = [
  // 'http://127.0.0.1:5501',
  'http://127.0.0.1:3000'
]
app.use(cors({
  origin: (origin, callback) => {
    if(!origin || allowedOrigins.includes(origin)) callback(null, true) //*âœ…Permite acceso
    else callback(new Error('origin no permitido por CORS'), false) //!ğŸš«Denegado acceso
  }

}))



2ï¸4ï¸âƒ£5ï¸âƒ£6ï¸âƒ£7ï¸âƒ£8ï¸âƒ£9ï¸âƒ£
